<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kotlin 核心概念解析</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            margin-top: 30px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            font-size: 0.9em;
        }
        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background-color: #e8e8e8;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
        }
        .explanation {
            margin-bottom: 20px;
        }
        .analogy {
            background-color: #e7f3fe;
            border-left: 4px solid #3498db;
            padding: 10px 15px;
            margin: 15px 0;
            font-style: italic;
        }
        strong {
            color: #3498db;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Kotlin 核心概念解析</h1>

        <!-- 作用域函数 -->
        <section id="scope-functions">
            <h2>一、作用域函数 (Scope Functions) - 通俗讲解</h2>
            <div class="explanation">
                <p>Kotlin 中的作用域函数就像是给你一个<strong>临时的、便捷的小工具箱</strong>，让你能更简洁地操作一个对象，而不需要反复写这个对象的名字。</p>
                <p>想象一下，你有一个叫 <code>person</code> 的对象，它有 <code>name</code> 和 <code>age</code> 属性，还有一个 <code>sayHello()</code> 方法。</p>
                <p><strong>没有作用域函数，你可能会这么写：</strong></p>
                <pre><code class="language-kotlin">
person.name = "Alice"
person.age = 30
person.sayHello()
println("Person's name is: " + person.name)
                </code></pre>
                <p>看到 <code>person.</code> 重复了好几次吗？有点啰嗦。</p>
                <p><strong>作用域函数能帮你简化这个过程。</strong> 它们主要有五个：<code>let</code>, <code>run</code>, <code>with</code>, <code>apply</code>, 和 <code>also</code>。</p>
                <p>它们的核心思想是：</p>
                <ol>
                    <li><strong>提供一个临时的作用域（一个代码块）</strong>。</li>
                    <li>在这个作用域里，你可以<strong>直接访问这个对象的属性和方法</strong>，或者以一种特殊的方式（比如用 <code>it</code>）来引用这个对象。</li>
                    <li>它们通常会<strong>返回一个结果</strong>（可能是对象本身，也可能是代码块最后一行表达式的结果）。</li>
                </ol>
            </div>

            <h3>简单通俗地理解每个函数：</h3>

            <h4>1. <code>let</code>：处理可空对象，并进行链式操作</h4>
            <div class="explanation">
                <p><strong>场景</strong>：当你需要对一个<strong>可能为空 (nullable) 的对象</strong>进行操作，并且只有当它不为空时才执行某些代码。或者你想把一个对象转换成另一个结果。</p>
                <p><strong>特点</strong>：</p>
                <ul>
                    <li>在 <code>let</code> 块内部，对象通过 <code>it</code> 来访问（你也可以自定义名字）。</li>
                    <li><code>let</code> 返回 lambda 表达式的结果（最后一行）。</li>
                </ul>
                <div class="analogy">
                    <strong>通俗比喻</strong>：像一个门卫。如果对象存在（不为空），门卫就放行，让你用 <code>it</code> 来操作它，并告诉你操作的结果是什么。如果对象为空，门卫就不让你进去。
                </div>
                <pre><code class="language-kotlin">
val name: String? = "Alice"
val length = name?.let {
    println("Name is: $it") // it 指向 "Alice"
    it.length // 返回长度
}
println("Length is: $length") // 输出 5

val noName: String? = null
noName?.let {
    println("This won't print") // 因为 noName 是 null，这里不执行
}
                </code></pre>
            </div>

            <h4>2. <code>run</code>：配置对象并计算结果</h4>
            <div class="explanation">
                <p><strong>场景</strong>：当你需要对一个对象进行一系列操作（比如初始化或配置），并且最后需要一个结果。</p>
                <p><strong>特点</strong>：</p>
                <ul>
                    <li>在 <code>run</code> 块内部，你可以直接用 <code>this</code> (或者省略 <code>this.</code>) 来访问对象的属性和方法。</li>
                    <li><code>run</code> 返回 lambda 表达式的结果（最后一行）。</li>
                </ul>
                <div class="analogy">
                    <strong>通俗比喻</strong>：像一个工作台。你把对象放到工作台上 (<code>this</code>)，对它进行各种加工，最后工作台告诉你加工完成后的成果是什么。
                </div>
                <pre><code class="language-kotlin">
// 辅助理解的 Person 类 (实际使用时需要定义)
data class Person(var name: String, var age: Int) {
    fun hasBirthday() { age++ }
}

val personRun = Person("Bob", 25)
val greeting = personRun.run {
    name = "Robert" // this.name
    age = 26       // this.age
    "Hello, my name is $name and I am $age years old." // 返回这个字符串
}
println(greeting) // 输出: Hello, my name is Robert and I am 26 years old.
                </code></pre>
                <p><code>run</code> 也可以不依赖对象直接使用，用来创建一个临时的作用域执行一些语句并返回结果。</p>
            </div>

           <!-- ... (第一部分 HTML 代码) ... -->

            <h4>3. <code>with</code>：与 <code>run</code> 类似，但调用方式不同</h4>
            <div class="explanation">
                <p><strong>场景</strong>：和 <code>run</code> 的场景一样，主要用于对一个对象进行一系列操作并可能返回一个结果。</p>
                <p><strong>特点</strong>：</p>
                <ul>
                    <li><code>with</code> 不是扩展函数，它是一个普通函数，第一个参数是你要操作的对象。</li>
                    <li>在 <code>with</code> 块内部，你也可以直接用 <code>this</code> (或者省略 <code>this.</code>) 来访问对象的属性和方法。</li>
                    <li><code>with</code> 返回 lambda 表达式的结果（最后一行）。</li>
                </ul>
                <div class="analogy">
                    <strong>通俗比喻</strong>：和 <code>run</code> 的工作台很像，只是你把对象递给它说：“用这个对象 (<code>person</code>) 来做这些事...”。
                </div>
                <pre><code class="language-kotlin">
// 辅助理解的 Person 类 (实际使用时需要定义)
// data class Person(var name: String, var age: Int) {
//     fun hasBirthday() { age++ }
// }

val personWith = Person("Charlie", 30)
val description = with(personWith) {
    println("Configuring $name") // this.name
    hasBirthday()               // this.hasBirthday()
    "Description: $name, Age: $age" // 返回这个字符串
}
println(description) // 输出: Description: Charlie, Age: 31 (假设 hasBirthday 增加了 age)
                </code></pre>
            </div>

            <h4>4. <code>apply</code>：配置对象并返回对象本身</h4>
            <div class="explanation">
                <p><strong>场景</strong>：当你需要对一个对象进行一系列配置或修改，并且之后你还想继续使用这个<strong>配置好后的对象本身</strong>。常用于对象初始化。</p>
                <p><strong>特点</strong>：</p>
                <ul>
                    <li>在 <code>apply</code> 块内部，你可以直接用 <code>this</code> (或者省略 <code>this.</code>) 来访问对象的属性和方法。</li>
                    <li><code>apply</code> <strong>总是返回对象本身</strong>（调用 <code>apply</code> 的那个对象）。</li>
                </ul>
                <div class="analogy">
                    <strong>通俗比喻</strong>：像一个装修队。你把房子 (<code>this</code>) 交给装修队，他们装修一番，然后把装修好的房子还给你。
                </div>
                <pre><code class="language-kotlin">
// 假设 TextView 和 Color 类已定义 (Android SDK 中的类)
// class TextView(context: Any?) {
//     var text: CharSequence = ""
//     var textSize: Float = 0f
//     fun setTextColor(color: Int) {}
// }
// object Color { const val BLUE = 1 }
// val context: Any? = null // 假设的上下文
// val layout = mutableListOf<TextView>() // 假设的布局

val myTextView = TextView(context).apply {
    text = "Hello"
    textSize = 16f
    setTextColor(Color.BLUE)
    // 这里不需要显式返回 myTextView，apply 会自动返回
}
// myTextView 现在是配置好的 TextView 对象
layout.add(myTextView)
println("TextView text: ${myTextView.text}") // 输出: TextView text: Hello
                </code></pre>
                <p>你提供的 <code>HomeViewModel</code> 例子中的 <code>MutableLiveData&lt;String&gt;().apply { value = "This is home Fragment" }</code> 就是一个典型的 <code>apply</code> 用法，用于创建并立即初始化对象。</p>
            </div>

            <h4>5. <code>also</code>：执行附加操作并返回对象本身</h4>
            <div class="explanation">
                <p><strong>场景</strong>：当你需要对一个对象执行一些<strong>额外的、不改变对象本身状态的操作</strong>（比如打印日志、做一些验证），并且之后你还想继续使用这个对象。</p>
                <p><strong>特点</strong>：</p>
                <ul>
                    <li>在 <code>also</code> 块内部，对象通过 <code>it</code> 来访问（你也可以自定义名字）。</li>
                    <li><code>also</code> <strong>总是返回对象本身</strong>（调用 <code>also</code> 的那个对象）。</li>
                </ul>
                <div class="analogy">
                    <strong>通俗比喻</strong>：像一个旁观者。你对一个对象做了一些事，然后叫旁观者 (<code>it</code>) 来看一下，记录一下或者做点别的不影响对象本身的事，最后对象还是那个对象。
                </div>
                <pre><code class="language-kotlin">
val numbersList = mutableListOf("one", "two", "three") // Renamed to avoid conflict
numbersList.also {
    println("The list before adding new element: $it") // it 指向 numbersList
}.add("four") // add("four") 是在 numbersList 上调用的，因为 also 返回了 numbersList

println("The list after adding new element: $numbersList")
// 输出:
// The list before adding new element: [one, two, three]
// The list after adding new element: [one, two, three, four]
                </code></pre>
            </div>

            <h3>总结一下选择哪个作用域函数：</h3>
            <ul>
                <li><strong>要对可空对象操作，并可能转换结果？</strong> &rarr; <code>let</code></li>
                <li><strong>要配置对象，并需要一个不同于对象本身的结果？</strong> &rarr; <code>run</code> (作为扩展函数) 或 <code>with</code> (作为普通函数)</li>
                <li><strong>要配置对象，并需要返回对象本身？</strong> &rarr; <code>apply</code> (常用于初始化)</li>
                <li><strong>要对对象执行一些附加操作（如日志），并需要返回对象本身？</strong> &rarr; <code>also</code></li>
            </ul>
            <p>它们都能让你的代码更流畅、更易读，一旦熟悉了，就会发现它们非常好用！</p>
        </section>

        <!-- Lambda 表达式 -->
        <section id="lambda-expressions">
            <h2>二、Lambda 表达式 - 通俗讲解</h2>
            <div class="explanation">
                <p>想象一下，你正在组织一个派对，需要一些帮手来完成一些小任务。</p>
                <p><strong>没有 Lambda 表达式的情况：</strong><br>
                每次你需要一个帮手做一件特定的、一次性的小事，你都得：</p>
                <ol>
                    <li><strong>郑重其事地给这个帮手起个名字</strong>（比如“切水果专员张三”、“摆盘子专员李四”）。</li>
                    <li><strong>详细地写下这个帮手的完整工作描述</strong>（比如“张三：拿起刀，把苹果切成块，把香蕉切成段……”）。</li>
                    <li><strong>然后告诉派对主持人</strong>：“请张三来做切水果的工作。”</li>
                </ol>
                <p>这就像在编程中定义一个完整的、有名字的函数，即使这个函数你可能只用一次。</p>
                <pre><code class="language-kotlin">
// 传统方式：定义一个完整的函数
fun double(x: Int): Int {
    return x * 2
}

fun main() {
    val numbers = listOf(1, 2, 3)
    val doubledNumbers = numbers.map(::double) // 使用函数引用
    println(doubledNumbers) // 输出 [2, 4, 6]
}
                </code></pre>
                <p><strong>有了 Lambda 表达式，就像是：</strong><br>
                你不再需要给每个临时帮手起正式的名字和写冗长的描述。你可以直接说：<br>
                “嘿，（<strong>指向一个临时工</strong>），你，把这个数乘以 2。”<br>
                或者<br>
                “找个人，（<strong>做个手势表示操作</strong>），把这些水果切一下。”</p>
                <p><strong>Lambda 表达式就是一个匿名的、临时的、迷你的“小函数”或“小任务指令”。</strong></p>
            </div>

            <h3>核心特点，通俗理解：</h3>
            <ol>
                <li><strong>匿名（没有名字）</strong>：
                    <ul>
                        <li>你不需要像 <code>fun myFunction()</code> 那样给它起个正式的名字。它就是一段代码块，直接定义要做什么。</li>
                        <li><div class="analogy"><strong>比喻</strong>：就像街头艺人，没有正式的艺名，但能表演。</div></li>
                    </ul>
                </li>
               <!-- ... (第二部分 HTML 代码) ... -->
                <li><strong>简洁（代码量少）</strong>：
                    <ul>
                        <li>通常用于定义那些逻辑比较简单、只用一两次的操作，所以语法设计得很紧凑。</li>
                        <li><div class="analogy"><strong>比喻</strong>：不是写一本厚厚的操作手册，而是一张简单明了的便签指令。</div></li>
                    </ul>
                </li>
                <li><strong>可以作为参数传递</strong>：
                    <ul>
                        <li>这是 Lambda 最强大的地方！你可以把这个“小任务指令”直接交给其他函数去执行。</li>
                        <li><div class="analogy"><strong>比喻</strong>：你写了个“把数字加倍”的便签，然后把这张便签递给一个叫 <code>map</code> 的“总管”，<code>map</code> 总管就会拿着你的便签对一堆数字逐个执行这个指令。</div></li>
                    </ul>
                </li>
                <li><strong>可以从上下文中推断类型</strong>：
                    <ul>
                        <li>很多时候，你不需要明确写出 Lambda 表达式的参数类型或返回类型，Kotlin 编译器能“猜”出来。</li>
                        <li><div class="analogy"><strong>比喻</strong>：你对一个成年人说“把这个苹果切了”，你不需要特地强调“用刀切”，他能明白。</div></li>
                    </ul>
                </li>
            </ol>

            <h3>Lambda 表达式的基本结构（Kotlin 中）：</h3>
            <p><code>{ 参数列表 -> 函数体 }</code></p>
            <ul>
                <li><strong><code>{ }</code> (花括号)</strong>：包围着整个 Lambda 表达式。</li>
                <li><strong><code>参数列表</code> (可选)</strong>：这个小任务需要哪些输入。如果没有输入，可以省略。
                    <ul><li>例如：<code>x</code> (一个参数), <code>(a, b)</code> (两个参数)</li></ul>
                </li>
                <li><strong><code>-></code> (箭头)</strong>：分隔参数列表和函数体。</li>
                <li><strong><code>函数体</code></strong>：具体要执行的操作。
                    <ul>
                        <li>如果函数体只有一行，这一行默认就是返回值。</li>
                        <li>如果有多行，最后一行表达式的结果是返回值。</li>
                    </ul>
                </li>
            </ul>

            <h3>看个例子，对比一下：</h3>
            <p>假设我们有一个数字列表，想把每个数字都乘以 2。</p>
            <p><strong>传统方式 (定义一个函数)：</strong></p>
            <pre><code class="language-kotlin">
fun doubleTheNumber(number: Int): Int {
    return number * 2
}
val numbersForLambda = listOf(1, 2, 3) // Renamed to avoid conflict
val doubledTraditional = numbersForLambda.map { doubleTheNumber(it) } // 或者 numbers.map(::doubleTheNumber)
// doubledTraditional 会是 [2, 4, 6]
println("Traditional: $doubledTraditional")
            </code></pre>
            <p><strong>使用 Lambda 表达式：</strong></p>
            <pre><code class="language-kotlin">
val numbersForLambda2 = listOf(1, 2, 3) // Renamed to avoid conflict

// 完整形式的 Lambda
val doubled1 = numbersForLambda2.map({ number: Int -> number * 2 })

// Kotlin 的魔法：
// 1. 如果 Lambda 是函数的最后一个参数，可以移到括号外
val doubled2 = numbersForLambda2.map() { number: Int -> number * 2 }

// 2. 如果函数只有一个 Lambda 参数，可以省略括号
val doubled3 = numbersForLambda2.map { number: Int -> number * 2 }

// 3. 如果参数类型可以推断出来，可以省略类型声明
val doubled4 = numbersForLambda2.map { number -> number * 2 }

// 4. 如果 Lambda 只有一个参数，可以用 `it` 隐式引用它
val doubled5 = numbersForLambda2.map { it * 2 } // 最简洁！

println("Lambda doubled1: $doubled1") // [2, 4, 6]
println("Lambda doubled5: $doubled5") // [2, 4, 6]
            </code></pre>
            <p>在 <code>doubled5</code> 中，<code>{ it * 2 }</code> 就是一个 Lambda 表达式。</p>
            <ul>
                <li>它没有名字。</li>
                <li>它很简洁。</li>
                <li>它被传递给了 <code>map</code> 函数。<code>map</code> 函数会对 <code>numbersForLambda2</code> 列表中的每个元素（这里用 <code>it</code> 代表每个元素）执行这个 Lambda 定义的操作（乘以 2）。</li>
            </ul>

            <h3>总结一下 Lambda 的通俗意义：</h3>
            <p>Lambda 表达式就是一种<strong>“随用随写，写完即焚”的小代码片段</strong>，特别适合传递给其他函数来定义一个临时的、具体的行为。它让代码更紧凑，尤其在处理集合数据或设置回调（当某事发生时执行的代码）时非常方便。</p>
            <p>把它想象成一个<strong>“一次性的小指令”</strong>或者一个<strong>“匿名的临时工”</strong>，专门用来快速完成某个简单任务。</p>
        </section>

        <!-- 函数引用 -->
        <section id="function-references">
            <h2>三、函数引用 (::) - 通俗讲解</h2>
            <div class="explanation">
                <p><code>::</code> 在 Kotlin 中被称为<strong>函数引用 (Function Reference)</strong> 或更广义地称为<strong>可调用引用 (Callable Reference)</strong>。</p>
                <p>它允许你像操作一个普通值一样来引用一个<strong>已存在的、有名字的函数、属性或构造函数</strong>。</p>
                <p>简单来说，<code>::</code> 的作用就是：<strong>“嘿，我不是要现在就调用这个函数/属性，而是想拿到一个指向它的‘指针’或‘名片’，这样我以后可以通过这个‘名片’来调用它，或者把它传递给其他需要函数作为参数的地方。”</strong></p>
            </div>

            <h3>主要用途和场景：</h3>
            <h4>1. 引用顶层函数或成员函数：</h4>
            <div class="explanation">
                <ul>
                    <li>当你需要将一个已定义的函数作为参数传递给另一个高阶函数（接收函数作为参数的函数）时。</li>
                    <li>当你需要将一个函数赋值给一个函数类型的变量时。</li>
                </ul>
                <pre><code class="language-kotlin">
fun sayHello(name: String) {
    println("Hello, $name!")
}

class Greeter {
    fun greet(message: String) {
        println("Greeter says: $message")
    }
}

fun main() { // Assuming this is within a main or similar executable scope
    // 1. 引用顶层函数
    val helloFunction: (String) -> Unit = ::sayHello
    helloFunction("Alice") // 调用: Hello, Alice!

    // 将函数引用传递给高阶函数 (比如 forEach)
    val names = listOf("Bob", "Charlie")
    names.forEach(::println) // println 是一个顶层函数

    // 2. 引用成员函数 (需要一个类的实例)
    val myGreeter = Greeter()
    val greetFunction: (String) -> Unit = myGreeter::greet // 绑定到特定实例
    greetFunction("Good morning") // 调用: Greeter says: Good morning

    // 也可以引用未绑定的成员函数 (需要先提供实例才能调用)
    val unboundGreet: (Greeter, String) -> Unit = Greeter::greet
    unboundGreet(myGreeter, "How are you?") // 调用: Greeter says: How are you?
    unboundGreet(Greeter(), "Another greeting") // 调用在另一个实例上
}
                </code></pre>
            </div>

            <!-- ... (第三部分 HTML 代码的开头) ... -->

            <h4>2. 引用属性：</h4>
            <div class="explanation">
                <p>你可以获取一个指向属性的引用，这允许你后续通过这个引用来获取属性的值或（如果是可变属性）设置属性的值。这在某些反射或元编程场景中很有用。</p>
                <pre><code class="language-kotlin">
class UserRef(var name: String, val age: Int) // Renamed to avoid conflict

// fun main() { // Assuming this is within a main or similar executable scope
    val userForRef = UserRef("David", 30) // Renamed to avoid conflict

    // 引用可变属性 (var)
    val nameProp = UserRef::name
    println("Prop get name: ${nameProp.get(userForRef)}") // 输出: David
    nameProp.set(userForRef, "Daniel")
    println("User name after set: ${userForRef.name}")         // 输出: Daniel

    // 引用只读属性 (val)
    val ageProp = UserRef::age
    println("Prop get age: ${ageProp.get(userForRef)}")  // 输出: 30
    // ageProp.set(userForRef, 31) // 编译错误，因为 age 是 val
// }
                </code></pre>
            </div>

            <h4>3. 引用构造函数：</h4>
            <div class="explanation">
                <p>你可以获取一个指向类构造函数的引用。这在你需要动态创建对象或者将构造逻辑作为参数传递时非常有用。</p>
                <pre><code class="language-kotlin">
class Message(val content: String)

// fun main() { // Assuming this is within a main or similar executable scope
    // 引用构造函数
    val messageConstructor: (String) -> Message = ::Message

    val msg1 = messageConstructor("Hello from constructor reference!")
    println("Msg1 content: ${msg1.content}") // 输出: Hello from constructor reference!

    // 假设有一个函数需要一个“工厂”来创建对象
    fun createAndPrint(text: String, factory: (String) -> Message) {
        val message = factory(text)
        println("Created via factory: ${message.content}")
    }

    createAndPrint("Test message", ::Message) // 输出: Created via factory: Test message
// }
                </code></pre>
            </div>

            <h3>通俗比喻：</h3>
            <div class="explanation">
                <p>想象一下：</p>
                <ul>
                    <li><strong>函数调用 <code>sayHello("Alice")</code></strong>：就像你直接拿起电话打给 Alice 并和她说话。</li>
                    <li><strong>函数引用 <code>::sayHello</code></strong>：就像你把 Alice 的电话号码写在一张纸条上。你现在并没有打电话，但你有了联系她的方式。你可以把这张纸条给你的朋友（另一个函数），你的朋友就可以用这个号码联系 Alice。</li>
                </ul>
            </div>

            <h3>总结 <code>::</code> 的含义：</h3>
            <ul>
                <li>它不是立即执行函数或访问属性。</li>
                <li>它创建了一个该可调用实体的<strong>引用</strong>或<strong>代理</strong>。</li>
                <li>这个引用可以像其他值一样被存储、传递。</li>
                <li>当你需要<strong>延迟执行</strong>、<strong>将行为作为数据传递</strong>，或者在某些框架（如序列化、依赖注入、UI事件处理）中指定要调用的代码时，函数/属性引用非常有用。</li>
            </ul>
            <p>它与 Lambda 表达式的区别在于：</p>
            <ul>
                <li><strong>Lambda 表达式 (<code>{ ... }</code>)</strong>：是定义一个<strong>新的、匿名的</strong>函数。</li>
                <li><strong>函数引用 (<code>::functionName</code>)</strong>：是引用一个<strong>已经存在的、有名字的</strong>函数（或属性/构造函数）。</li>
            </ul>
            <p>两者都可以用于高阶函数期望一个函数类型参数的场景。选择哪个取决于你是否已经有一个合适的命名函数，或者是否需要一个临时的、内联的逻辑。</p>
        </section>

    </div> <!-- end .container -->
</body>
</html>